{"meta":{"title":"龚俊龙-Blog","subtitle":"","description":"","author":"龚俊龙","url":"http://blog.loveapple.top","root":"/"},"posts":[{"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.loveapple.top/tags/JS/"}],"title":"闭包用法","date":"2019/12/27","text":"JS闭包，作用域，this 一、闭包 1、变量的作用域 要理解闭包，首先必须理解JavaScript特殊的作用域。 变量的作用域分为两种：全局变量和局部变量。 a、函数内部可以直接读取全局变量： var n=999; function f1(){ alert(n); } f1(); // 999 b、函数外部无法读取函数内部的局部变量 function f1(){ var n=999; } alert(n); // error c、函数内部声明变量时，必须使用var命令。如果不用的话，实际上声明了一个全局变量。 function f1(){ n=999;}f1();alert(n); // 999 2、如何从外部读取局部变量 在函数的内部，再声明一个函数。 function f1(){ var n=999; function f2(){ alert(n); //999 } } 解释：在上述代码中，函数f2就被包括在函数f1里面，函数f1的所有局部变量对f2都是可见的。但是反过来就不行了，f2中的局部变量，在f1中是不可见的。这就是JavaScript语言特有的“链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量，所以，父对象的所有变量，子对象都是可见的，反之则不行。 既然在函数f2中可以读取函数f1中的局部变量，那么我们只要把函数f2作为返回值，就可以在函数f1外面读取它的局部变量了。 function f1(){ var n=999; function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999 3、闭包的概念 上一节代码中的函数f2就是闭包。 我的理解是：闭包是能够读取其他函数内部变量的函数。 由于在JavaScript语言中，只有函数内部的子函数才能访问此函数的局部变量，因此可以简易的把闭包称为“定义在一个函数内部的函数”。 所以，在本质上，闭包是函数内部和函数外部连接的一座桥梁。 自己总结：闭包可以解决函数外部无法访问函数内部变量的问题。 闭包还有一个大的特点就是通过闭包我们可以让函数中的变量持久保持。 function fn(){ var num = 5; num+=1; alert(num); } fn(); //6 fn(); //6 为什么呢？因为函数一旦调用里面的内容就会被销毁，下一次调用又是一个新的函数，和上一个调用的不相关了。 function fn(){ var num = 0; return function(){ num+=1; alert(num); }; } var f = fn(); f(); //1 f(); //2 我们首页定义了一个fn函数，里面有个num默认为0，接着返回了一个匿名函数（也就是没有名字的函数）。我们在外部用f接收这个返回的函数。这个匿名函数干的事情就是把num加1。 这里之所以执行完这个函数num没有被销毁是因为那个匿名函数的问题，因为这个匿名函数用到了这个num，所以没有被销毁，一直保持在内存中，因此我们f()时num可以一直加。 4、闭包的用途 闭包可以用在许多地方。最大的两个用处：一是可以读取到函数内部的变量；二是可以让这些变量的值始终保存在内存中。 function f1() { var n = 999; nAdd = function () { n += 1 } function f2() { alert(n); } return f2; } var result=f1(); result(); // 999 nAdd(); result(); // 1000 在上面代码中，其实result就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在函数f1调用后被自动清除。 为什么会这样呢？原因在于函数f1是函数f2的父函数，而函数f2被赋予了一个全局变量n，导致函数f2始终在内存中，而f2是依赖于f1的，所以f1也存在于内存中，不会在调用结束后，被垃圾回收机制回收。 注意：在上面代码中，”nAdd=function(){n+=1}”这一行，nAdd前面没有使用var，那么它就是一个全局变量。其次，它还是一个匿名函数，而这个匿名函数也是一个闭包，所以nAdd相当于一个setter，可以在函数外部调用它。 5、使用闭包的注意点 由于闭包会使得函数中的变量都保存到内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能的问题，在IE中可能会导致内存泄漏。解决方法是，在退出函数时，将不使用的局部变量删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 6、思考题 代码片段一： var name = “The Window”; var object = { name : “My Object”, getNameFunc : function(){ return function(){ return this.name; }; }, getName:function(){ alert(this.name); } }; alert(object.getNameFunc()()); //The Window object.getName(); //My Object 解析：object.getNameFunc()返回的是一个匿名函数function(){return this.name;}，此时this指向全局对象window，所以输出The Window；object.getName()的上下文是object，所以输出My Object。 代码片段二： var name = “The Window”; var object = { name : “My Object”, getNameFunc : function(){ var that = this; return function(){ return that.name; }; } }; alert(object.getNameFunc()()); //My Object 解析：getNameFunc 匿名函数属于object对象的函数,this 赋给 that,导致最后return的函数依赖getNameFunc ，不会被回收。 二、js中this的指向 1、this的一般情况 this的指向在函数定义的时候是不明确的，只有在函数被调用执行时才能确定其指向，实际上this最终指向的是那个调用他的对象。 例子1： function a(){ var user = &quot;追梦子&quot;; console.log(this.user); //undefined console.log(this); //Window}a(); //等价于 window.a(); 这里的函数a实际上是被Window对象点击出来的，所以this指向的就是Window。 例子2： var o = { user:&quot;追梦子&quot;, fn:function(){ console.log(this.user); //追梦子 }}o.fn(); //等价于 window.o.fn(); 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o。 例子3： var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //12 } } } o.b.fn(); 补充： var o = { a:10, b:{ // a:12, fn:function(){ console.log(this.a); //undefined } } } o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 特殊： var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //undefined console.log(this); //window } } } var j = o.b.fn; j(); this永远指向最后调用他的对象。虽然fn是被b所引用，但是在给j赋值的时候并没有调用指向fn，而最后是window调用j来执行的，所以this指向windo。 2、构造函数版this function Fn(){ this.user = “追梦子”; } var a = new Fn(); console.log(a.user); //追梦子 这里的对象a能够点出函数fn的user，是因为new关键字可以改变this的指向，将这个this指向对象a，a之所以是一个对象，是因为new关键字是创建一个对象。 3、当this碰到return function fn() { this.user = ‘追梦子’; return {}; } var a = new fn; console.log(a.user); //undefined function fn() { this.user = ‘追梦子’; return function(){}; } var a = new fn; console.log(a.user); //undefined function fn() { this.user = ‘追梦子’; return 1; } var a = new fn; console.log(a.user); //追梦子 function fn() { this.user = ‘追梦子’; return undefined; //替换成 return null 结果也是这样; } var a = new fn; console.log(a.user); //追梦子 如果返回值是一个对象，那么this指向的就是这个对象，如果返回的不是一个对象，那么指向的还是函数的实例。 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 三、for循环经典列子 例子1： window.onload = function(){ var box = document.getElementById(&quot;box&quot;); var num = 0; function a(){ console.log(num); } box.onclick = function(){ num ++; a(); // 1,2,3,4....每次单击都会加1，说明函数引用外部变量是引用那个变量的最后一次的值。 }} 例子2： window.onload = function(){ var box = document.getElementById(&quot;box&quot;); var num = 0; for(var i=0;i&lt;10;i++){ box.onclick = function(){ console.log(i); //总是打印10 } }} 例子2中，每次点击都是打印10，而不是打印1,2,3,4…，这是为什么呢？因为当你for循环时，并没有执行这个函数，当你点击的时候执行此函数，它会发现它没有此变量i，于是向它的作用域链中查找此变量，而此时变量i的值为10，所有每次点击后输出的结果都为10。 例子3： window.onload = function(){ var div = document.getElementsByTagName(“div”); var num = 0; for(var i=0;i&lt;div.length;i++){ (function(i){ div[i].onclick = function(){ console.log(i); //1,2,3,4….. } })(i) } } 上面代码能够实现每次点击都出现不同的数字，但是这样会将i一直保存在内存中，比较消耗性能。","permalink":"http://blog.loveapple.top/2019/12/27/JS%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cthis/","photos":[]},{"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.loveapple.top/tags/JS/"}],"title":"JS闭包理解","date":"2019/12/19","text":"对Js中闭包的理解 1.变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量另一方面，在函数外部自然无法读取函数内的局部变量这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立这就是Javascript语言特有的“链式作用域”结构（chain scope） 2.闭包的概念官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 3.闭包的用途它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 4.使用闭包的注意点闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值 5.Javascript的垃圾回收机制在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 闭包面试 面试一句话回答：闭包就是能够读取函数内部变量的内层函数，是“定义在一个函数内部的函数”。因为js的链式作用域，内层函数能访问外层函数的变量，但外层函数不能直接访问内层函数的变量。如果想从外部读取函数的局部变量，这时候就需要用闭包。 问：为什么会出现闭包？答：外层函数不能访问内层函数的变量（js的链式作用域：子对象会一级一级地向上寻找所有父对象的变量，反之不可）。 问：什么时候用闭包？答：想从外部读取函数的局部变量，这时候就需要用闭包。 闭包概念：闭包就是能够读取函数内部变量的内层函数，可以把闭包简单理解成”定义在一个函数内部的函数”。 问：内层函数为什么能访问外层函数的变量？答：是因为Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。 问：如何从外部读取函数的局部变量呢？答：在函数的内部，再定义一个函数，然后返回这个函数。 闭包的用处有两个： 可以读取函数内部的变量 让这些变量的值始终保持在内存中 使用闭包的注意点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","permalink":"http://blog.loveapple.top/2019/12/19/JS%E9%97%AD%E5%8C%85%E7%9F%A5%E8%AF%86/","photos":[]},{"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://blog.loveapple.top/tags/GitHub/"}],"title":"Markdown语法","date":"2019/12/17","text":"什么是 Markdown ? Markdown 是一种可以使用普通文本编辑器编写的标记语言, 通过简单的标记语法, 它可以使普通文本内容具有一定的格式。 目录 分级标题 分隔线 超链接 行内式 参考式 自动链接 区块引用 引用的多层嵌套 引用其它要素 锚点 强调 斜体 粗体 删除线 列表 无序列表 有序列表 包含引用的列表 插入图片 图片行内式 图片参考式 表格 代码 代码行内式 缩进式多行代码 [用六个`包裹多行代码](#用六个–包裹多行代码) HTML 原始码 内容目录 注脚 LaTeX 公式 $ 表示行内公式 $$ 表示整行公式 流程图 时序图 待办事宜列表 分级标题第一种写法: 12345这是一个一级标题============================这是一个二级标题-------------------------------------------------- 这是一个一级标题这是一个二级标题 第二种写法: 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线, 行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线: 123456789* * *********- - ---------------------------------------- 超链接Markdown 支持两种形式的链接语法: 行内式和参考式两种形式, 行内式一般使用较多。 行内式[]里写链接文字，()里写链接地址, ()中的 &quot;&quot; 中可以为链接指定title属性, title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 &quot;链接标题&quot;) 这样的形式。链接地址与链接标题前有一个空格。 12[Markdown Syntax](https://github.com/cdoco/markdown-syntax)[Markdown Syntax](https://github.com/cdoco/markdown-syntax \"Markdown Syntax\") Markdown Syntax Markdown Syntax 参考式参考式超链接一般用在学术论文上面, 或者另一种情况, 如果某一个链接在文章中多处使用, 那么使用引用的方式创建链接将非常好, 它可以让你对链接进行统一的管理。 参考式链接分为两部分, 文中的写法 [链接文字][链接标记]，在文本的任意位置添加 [链接标记]:链接地址 &quot;链接标题&quot;, 链接地址与链接标题前有一个空格。 123全球最大的搜索引擎网站是[Google][1]。[1]:http://www.google.com \"Google\" 全球最大的搜索引擎网站是 Google。 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱, 只要是用 &lt;&gt; 包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样, 例如: 123&lt;https://google.com/&gt;&lt;ocdoco@gmail.com&gt; https://google.com/ &#x6f;&#99;&#x64;&#111;&#x63;&#x6f;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109; 区块引用区块引用需要在被引用的文本前加上 &gt; 符号。 123&gt; 这是一个区块引用实例,&gt; Markdown. 这是一个区块引用实例, Markdown. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; : 123456&gt; 平生不会相思,才会相思,便害相思。&gt; 空一缕余香在此,盼千金游子何之。 平生不会相思,才会相思,便害相思。 空一缕余香在此,盼千金游子何之。 引用的多层嵌套区块引用可以嵌套（例如：引用内的引用）, 只要根据层次加上不同数量的 &gt; : 12345&gt;&gt;&gt; 锄禾日当午, 汗滴禾下土。 - 李绅&gt;&gt; 山有木兮木有枝, 心悦君兮君不知。 - 越人歌&gt; 去年今日此门中, 人面桃花相映红。 - 崔护 锄禾日当午, 汗滴禾下土。 - 李绅 山有木兮木有枝, 心悦君兮君不知。 - 越人歌 去年今日此门中, 人面桃花相映红。 - 题都城南庄 引用其它要素引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等: 12345678&gt; - 入我相思门, 知我相思苦。&gt;&gt; - 长相思兮长相忆, 短相思兮无穷极。&gt;&gt; - 给出一些例子代码:&gt; ```markdown&gt; return debug_backtrace();&gt; 123456789&gt; - 入我相思门, 知我相思苦。&gt;&gt; - 长相思兮长相忆, 短相思兮无穷极。&gt;&gt; - 给出一些例子代码:&gt; &#96;&#96;&#96;markdown&gt; return debug_backtrace();&gt; 锚点网页中, 锚点其实就是页内超链接, 也就是链接本文档内部的某些元素, 实现当前页面中的跳转。比如我这里写下一个锚点, 点击回到目录, 就能跳转到目录。 在目录中点击这一节, 就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。 1**[⬆ top](#什么是-markdown-)** ⬆ top 强调Markdown 使用星号*和底线_作为标记强调字词的符号。 斜体1*花自飘零水自流* 花自飘零水自流 粗体1**花自飘零水自流** 花自飘零水自流 删除线1~~花自飘零水自流~~ 花自飘零水自流 列表使用 *，+，- 表示无序列表。 无序列表123- 白头吟- 击鼓- 断句 白头吟 击鼓 断句 有序列表有序列表则使用数字接着一个英文句点。 1231. 白头吟2. 击鼓3. 断句 白头吟 击鼓 断句 包含引用的列表如果要在列表项目内放进引用，那 &gt; 就需要缩进: 1234* 菩提偈: &gt; 菩提本无树，明镜亦非台。 &gt; 本来无一物，何处惹尘埃！ 菩提偈: 菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！ 插入图片图片的创建方式与超链接相似, 而且和超链接一样也有两种写法, 行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示, 就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样, 表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的, 可以省略, 但建议写上。 图片行内式![图片Alt](图片地址 &quot;图片Title&quot;) 1![哆啦A梦](https://cdoco.com/images/duolaameng.jpeg \"哆啦A梦\") 图片参考式在文档要插入图片的地方写 ![图片Alt][标记]。 在文档的最后写上 [标记]:图片地址 &quot;Title&quot;。 123![哆啦A梦][duolaameng][duolaameng]:https://cdoco.com/images/duolaameng.jpeg \"哆啦A梦\" 表格 不管是哪种方式, 第一行为表头, 第二行分隔表头和主体部分, 第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐, 在-右边加上:就右对齐。 简单方式: 12345诗名|作者|朝代-|-|-白头吟|卓文君|两汉锦瑟|李商隐|唐代登科后|孟郊|唐代 诗名 作者 朝代 白头吟 卓文君 两汉 锦瑟 李商隐 唐代 登科后 孟郊 唐代 原生方式: 12345|诗名|作者|朝代||-|-|-||白头吟|卓文君|两汉||锦瑟|李商隐|唐代||登科后|孟郊|唐代| 诗名 作者 朝代 白头吟 卓文君 两汉 锦瑟 李商隐 唐代 登科后 孟郊 唐代 为表格第二列指定方向: 1234诗名|名句-|-:梦微之|君埋泉下泥销骨。上邪|上邪，我欲与君相知，长命无绝衰。 诗名 名句 梦微之 君埋泉下泥销骨。 上邪 上邪，我欲与君相知，长命无绝衰。 代码对于程序员来说这个功能是必不可少的, 插入程序代码的方式有两种, 一种是利用缩进(Tab), 另一种是利用 “`” 符号(一般在ESC键下方)包裹代码。 插入行内代码, 即插入一个单词或者一句代码的情况，使用 `code` 这样的形式插入。 插入多行代码, 可以使用缩进或者 ``` code ```, 具体看示例。 代码行内式1PHP打印堆栈信息 `debug_backtrace()`。 PHP打印堆栈信息 debug_backtrace()。 缩进式多行代码缩进 4 个空格或是 1 个制表符。 一个代码区块会一直持续到没有缩进的那一行(或是文件结尾)。 123$closure = function () use($name) &#123; return $name;&#125; $closure = function () use($name) { return $name; }用六个 ` 包裹多行代码12345```php$closure = function () use($name) &#123; return $name;&#125;` `` 123$closure = function () use($name) &#123; return $name;&#125; HTML 原始码在代码区块里面, &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体, 这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码, 只需要复制贴上, 剩下的 Markdown 都会帮你处理，例如: 12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 注脚在需要添加注脚的文字后加上脚注名字[^注脚名字], 称为加注。 然后在文本的任意位置(一般在最后)添加脚注, 脚注前必须有对应的脚注名字。 12345使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。[^1]: Markdown 是一种纯文本标记语言[^2]: HyperText Markup Language 超文本标记语言 PS: github 不支持注脚 :joy: LaTeX 公式$ 表示行内公式1质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 质能守恒方程可以用一个很简洁的方程式 来表达。 $$ 表示整行公式123$$\\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$$$\\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\\widehat&#123;\\gamma&#125;_&#123;kj&#125; z_k&#125;$$ PS: github 不支持 LaTeX 公式, 但是有个折中的解决方案, 使用 codecogs, 例如: 12![](https://latex.codecogs.com/gif.latex?sum_&#123;i=1&#125;^n%20a_i=0)![](https://latex.codecogs.com/gif.latex?f\\(x_1,x_x,\\ldots,x_n\\)%20=%20x_1^2%20+%20x_2^2%20+%20\\cdots%20+%20x_n^2%20) 流程图流程图大致分为两段, 第一段是定义元素, 第二段是定义元素之间的走向。 定义元素的语法 tag=&gt;type: content:&gt;url。 tag就是元素名字。 type是这个元素的类型, 有6中类型,分别为: type 含义 start 开始 end 结束 operation 操作 subroutine 子程序 condition 条件 inputoutput 输入或产出 content 就是在框框中要写的内容, 注意type后的冒号与文本之间一定要有个空格。 用-&gt;来连接两个元素, 需要注意的是condition类型, 因为他有yes和no两个分支, 所以要写成: 12c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e 1234567891011```flowst=&gt;start: Start:&gt;https://www.markdown-syntax.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io` `` PS: github 不支持流程图 :joy: 时序图12345```sequenceAlice-&gt;Bob: Hello Bob, how are you ?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!` `` PS: github 不支持时序图 :joy: 待办事宜列表使用带有 [ ] 或 [x] (未完成或已完成)项的列表语法撰写一个待办事宜列表, 例如: 12* [ ] 早起跑步* [x] 看书 早起跑步 看书 ⬆ top","permalink":"http://blog.loveapple.top/2019/12/17/Markdown%E8%AF%AD%E6%B3%95/","photos":[]},{"tags":[{"name":"学习项目","slug":"学习项目","permalink":"http://blog.loveapple.top/tags/%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE/"}],"title":"前端资源项目整合","date":"2019/12/17","text":"vue.js高仿饿了么（1-13章全） 链接：https://pan.baidu.com/s/1qYSiYXluA1AlEV0EskxWZw提取码：25z9Vue.js 2.5 + cube-ui 重构饿了么 App 链接：https://pan.baidu.com/s/1UZyLkzYMvhUhhX3GH5ITvA提取码：bx53Vue2.0 + Node.js + MongoDB全栈打造商城系统 链接：https://pan.baidu.com/s/1EmAvM3kryVQa3mQkwSY_Aw提取码：3fqtVue 2.0 高级实战-开发移动端音乐 WebApp 链接：https://pan.baidu.com/s/1RvF1KziTgq4HEaIVnCvz1w提取码：v0vbvue去哪儿无密APP 链接：https://pan.baidu.com/s/1vQMWuSNJJ8OrxoGVcZTgtw提取码：u3yzVue全家桶+SSR+Koa2全栈开发美团网 链接：https://pan.baidu.com/s/1KTzsYSB5-Ua47r-jArSgJw提取码：qwen7天搞定Node.js微信公众号开发 链接：https://pan.baidu.com/s/1Aw6be7tp8ysDs0N1H7Kf_Q提取码：gf6qVue + Node + MongoDB高级全栈 链接：https://pan.baidu.com/s/1dK5XH_Uxi21dZTYwGR-KkQ提取码：ta3s尚硅谷VUE核心技术视频 链接：https://pan.baidu.com/s/1hYxRi5nw82Au9AKdvo4RhQ提取码：aoohVue核心技术 Vue+Vue-Router+Vuex+SSR实战精讲 链接：https://pan.baidu.com/s/1TKaSoWhLfxdHZifYMwPbzw提取码：rbcyVue2.x实战项目(axios路由vuex) 链接：https://pan.baidu.com/s/1YPYORI7SnHgGo5Gq7zzGsA提取码：so0hMUI 仿豆瓣电影 APP跨平台混编框架 链接：https://pan.baidu.com/s/1CErOI6eWLEhf3qJeSALAng提取码：59qswebApp书城整站开发 链接：https://pan.baidu.com/s/1nA7CXe_1IYnmQibK3-ETig提取码：orulKoa2框架从0开始构建预告片网站 链接：https://pan.baidu.com/s/1UiwmhLnX1XOCLCAg_rLJwA提取码：l0kj响应式网页制作实战项目 链接：https://pan.baidu.com/s/1pHEe8p0b3f-JbQ7A0D1Xhw提取码：7lonIonic2飞速上手的跨平台App开发 链接：https://pan.baidu.com/s/1y3psOTyHez06Xfe9Jb-tWw提取码：0eje快速上手Ionic3 多平台开发企业级问答社区 链接：https://pan.baidu.com/s/1OJhxoef5v6BL9W6MnjNZ3Q提取码：souyWebpack + React全栈工程架构项目实战精讲 链接：https://pan.baidu.com/s/1gUDZ5sDBIGNa_jnJnioWgQ提取码：t4zqRedux + react + Router + Node.js全栈开发 链接：https://pan.baidu.com/s/1aDUmEJIt3USjxwVQrT-Mkg提取码：olfgReact16 + React-Router4 从零打造企业级电商后台管理系统 链接：https://pan.baidu.com/s/1Hlykhdh0Nm02SMj1NxDqbw提取码：m47bReact.js入门与实战[开发适配PC端及移动端新闻头条平台] 链接：https://pan.baidu.com/s/1GrBYd69i7LmiD6ONIT9zGw提取码：vcjbReact 高级实战 打造大众点评 WebApp 链接：https://pan.baidu.com/s/10aUtKTFc2lA2uLrqCOsv3Q提取码：f6amReact Native开发App狗狗说 链接：https://pan.baidu.com/s/1uZBZsviDWJOAMrb98GDijQ提取码：gmtt掌握React Native技术转型随意切换 链接：https://pan.baidu.com/s/1OLf5EHEeCvTkqBbxft_jsA提取码：hjjiReactJS 链接：https://pan.baidu.com/s/1dNf4fNWLyZ8kTwsOne564Q提取码：hd6o慕课网实战 贯穿全栈React Native开发App 链接：https://pan.baidu.com/s/13spZQ3nGBZiiT9dsakEY0g提取码：7jqz东方要React-native全教程 链接：https://pan.baidu.com/s/1k7D5QHrJAae3SyV7fgH_Pg提取码：zzpbReact 框架课程套装 链接：https://pan.baidu.com/s/1NfYV4qfKdi95GbebH-PNaA提取码：s9uvReact 高级实战大众点评 链接：https://pan.baidu.com/s/1vrItn64u49mwXMkG0foItg提取码：ceozReact Native 快速开发App一步到位 链接：https://pan.baidu.com/s/1vIaYd68hPC6WZTTGEuLFog提取码：jtr9彻底征服 React.js 链接：https://pan.baidu.com/s/1XwzTYO8U3Z9mN6PIP4gafQ提取码：4sp3React.js es6包含实战 链接：https://pan.baidu.com/s/1l4jh_kIOsXEKSaIo4fUzIA提取码：gdp6React+Redux+react-router 链接：https://pan.baidu.com/s/1xNPe582fJsMoVObw5_O5Bw提取码：yr94React Native小码哥电商 链接：https://pan.baidu.com/s/1ev6I-2qkFZry0ar_LnaZ4A提取码：96dwReact Native快速开发-厕所在哪App 链接：https://pan.baidu.com/s/1cKSNHhNkK0mC6bUOHaIPsg提取码：u5clReact 苹果官网产品展示效果+源码等多个文件 链接：https://pan.baidu.com/s/1bPfUcAHH0g8eLFIDqtBNpQ提取码：54o2Angular JS 仿拉勾网 WebApp 链接：https://pan.baidu.com/s/1EaEdEkFZMLvI3NNPYodc5A提取码：5tkcAngular 打造企业级协作平台 链接：https://pan.baidu.com/s/1vEsBm8drlsyYI3vYVT1m7A提取码：vysnAngular 4.0从入门到实战 打造股票管理网站 链接：https://pan.baidu.com/s/1CKOtDYw25maVbkYDh84qig提取码：kodfAngularJS全栈开发知乎 链接：https://pan.baidu.com/s/1wUHp0kF1wcDBNpH4qUOJrg提取码：bbi6AngularJS 链接：https://pan.baidu.com/s/17cLzs-AkNAqD8eLR9hmeOg提取码：qyxaAngular4 视频教程-it营（大地） 链接：https://pan.baidu.com/s/1NiwYVNiQORp9s1IPlK8lZw提取码：kxz5手把手从0打造电商平台 链接：https://pan.baidu.com/s/1o81d8TozMI72MX_IIRCD9w提取码：bq1yES6+ 开发电商网站的账号体系 JS SDK 链接：https://pan.baidu.com/s/19Tqk4ERUM7m3PdhGDAss7A提取码：12dkES6零基础教学 解析彩票项目 链接：https://pan.baidu.com/s/1A7gSrfadxw88lVwiP98Skg提取码：cdd7Node.js入门到企业Web开发中的应用 链接：https://pan.baidu.com/s/1Qt252KSqSAIJi-EmKib4PQ提取码：qnrdNode.js项目线上服务器部署与发布 链接：https://pan.baidu.com/s/1WmKWjLzuuGXbkK9qFnrLeQ提取码：c6md四大维度解锁 Webpack 3.0 前端工程化 链接：https://pan.baidu.com/s/1hXgm27tTZoRBN8HCE7W0Hw提取码：85yw6小时 jQuery开发一个前端应用 链接：https://pan.baidu.com/s/1hwO36zQKZp1gKx6mHxKQ_w提取码：hnaoHTTP协议原理+实践 Web开发工程师必学 链接：https://pan.baidu.com/s/1isAvkjKOMLsWGGNckOXsPw提取码：mk98微信小程序入门与实战 链接：https://pan.baidu.com/s/1EGZ8QG9MJJjJ_3wTu3Wmeg提取码：rme0全新升级 Kotlin系统入门与进阶 链接：https://pan.baidu.com/s/1WF6ORDNrg4Mel4HllX0zTg提取码：h4mnKotlin打造完整电商APP 模块化 + MVP + 主流框架 链接：https://pan.baidu.com/s/1CW-EV7HU70btAOs_v0uMVQ提取码：nrht开课吧第六期全栈架构师 链接：https://pan.baidu.com/s/1Z2zHnDBA1VzzznnGoVvscQ提取码：ncqj爱前端-邵山欢大前端全套完整教程 链接：https://pan.baidu.com/s/1cp9XG8eVFc-IBFUt7sjCUA提取码：bbys2018年黑马前端培训全套 链接：https://pan.baidu.com/s/1e2KGcK8aEEJRdjHOU8yBog提取码：sasv传智黑马39期【前端】 链接：https://pan.baidu.com/s/1tWp1zWv67W8C1TUJgzWV3A提取码：82br","permalink":"http://blog.loveapple.top/2019/12/17/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88/","photos":[]},{"tags":[],"title":"前端常用跨域处理","date":"2019/12/15","text":"前端常见跨域解决方案（全）","permalink":"http://blog.loveapple.top/2019/12/15/%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86/","photos":[]},{"tags":[],"title":"主题使用说明","date":"2019/12/13","text":"HEXO-GONG1 介绍 简单、突出文字，是开发的初衷 一个在 Hexo 博客上开发的主题，主题会持续更新 近日服务器搬迁完成，腾出时间来完善一下博客文档 2 安装1git clone https://github.com/shixiaohu2206/hexo-theme-huhu.git themes/hexo-theme-huhu 在项目根目录操作以上命令，并修改根目录下的 _config.yml 中的 theme 为 hexo-theme-huhu 本主题需要安装shelljs，因为 requiresJS 打包时，需要执行 bash 命令 1npm install --save shelljs 3 站内搜索目前主题只支持自生成搜索文件的方式，因为依赖第三方站内搜索，始终不是很稳定的赶脚，而且会加载许多第三方的服务文件，导致博客首屏加载慢 3.1 安装安装hexo-generator-json-content插件，用于生成站内搜索生成文件 1npm install --save hexo-generator-json-content 在根目录下的 _config.yml 中新增配置，如下: 123456789101112#https://github.com/alexbruno/hexo-generator-json-contentjsonContent: dateFormat: YYYY/MM/DD pages: false posts: tags: true title: true date: true text: true permalink: true photos: true file: content.json 4 新建 about 页面about 页面没有单独 layout，直接以 markdown 渲染 1hexo new page \"about\" 5 新建 tags、categories、friends 页面tags、categories、friends 有单独的 layout，所以新增命令后，需要在对应的文件中新增 layout 参数 12345hexo new page \"tags\"hexo new page \"friends\"hexo new page \"categories\" 请自行添加，例如： 123---layout: tags--- 5.1 friends 友链在根目录下的 _config.yml 中新增配置，例如： 123456friends: - name: Don Lex time: '2019-10-12' url: 'https://www.donlex.cn/' logo: 'https://www.donlex.cn/images/avatar.png' intro: '码农' 6 Google 相关配置如果使用 GTM 统计、Goole 站点、Google 广告等，则在根目录配置 _config.yml 中添加配置 12345678#google-site-verification 添加在meta信息中google_site_verification: ''#google gtmgtm_id: ''#google gtmgoogle_ad_client: '' 7 Baidu 相关配置主题新加了一个百度统计图表功能，使用方法见链接 使用百度站点、百度联盟、百度统计等功能，在根目录配置 _config.yml 中添加配置 1234567891011# 百度站点验证码baidu_site_verification: ''#百度联盟验证baidu_union_verify: ''#百度统计baidu_tongji: site_from: '2019/7/26' site_id: '' access_token: 'xxxxx' 8 代码高亮本主题支持 highlight.js 官方的 css，highlight.js 官网看中哪个颜色搭配，复制 css 样式替换themes\\huhu\\source\\style\\highlight.styl 新增 hljs 参数，并设为 trye，不然无法使用 highlight.js 官方的 css 123456highlight: enable: true hljs: true #新增hljs参数，并设为true，不然无法使用highlight.js 官方的 css line_number: false #暂不支持行号 auto_detect: false #这一项也关闭，若开启有可能报错 tab_replace: 9 文章评论支持两种方案，二选一 valine 畅言 9.1 valine 评论官网教程，在根目录配置 _config.yml 中添加 1234#valine评论valine: API_ID: '' API_KEY: '' 9.2 畅言评论官网教程，在根目录配置 _config.yml 中添加 1234#畅言评论changyan: appid: '' conf: '' 10 RSS安装插件hexo-generator-feed 1npm install --save hexo-generator-feed 在根目录配置 _config.yml 中添加 1234567891011#rssfeed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: '' order_by: -date icon: icon.png 11 置顶12345#卸载官方插件npm uninstall hexo-generator-index --save#安装插件npm install hexo-generator-index-pin-top --save 在 markdown 文件的 Front-matter，新增 top: 1即可，top 值越大，越靠前展示 主题在列表页增加了置顶的小图标，具体样式查看虎虎博客 12 兼容性使用了 Flex 布局，不支持 IE8 13 自定义其他的自定义，修改也很方便，比如更换打赏二维码、Follow 地址，都在主题的配置中themes\\huhu\\_config.yml，各位大佬请自行修改","permalink":"http://blog.loveapple.top/2019/12/13/hexo%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","photos":[]},{"tags":[],"title":"Promise","date":"2019/12/13","text":"1.什么是 Promise Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有 all、reject、resolve 这几个方法，原型上有 then、catch 等方法。 Promise 对象有以下两个特点。 （1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 下面先 new 一个 Promise let p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log('执行完成Promise'); resolve('要返回的数据可以任何数据例如接口返回数据'); }, 2000); }); 刷新页面会发现控制台直接打出 其执行过程是：执行了一个异步操作，也就是 setTimeout，2 秒后，输出“执行完成”，并且调用 resolve 方法。 注意！我只是 new 了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用 Promise 的时候一般是包在一个函数中，在需要的时候去运行这个函数，如： &lt;div onClick={promiseClick}&gt;开始异步请求&lt;/div&gt; const promiseClick =()=&gt;{ console.log(‘点击方法被调用’) let p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(‘执行完成Promise’); resolve(‘要返回的数据可以任何数据例如接口返回数据’); }, 2000); }); return p } 刷新页面的时候是没有任何反映的，但是点击后控制台打出 当放在函数里面的时候只有调用的时候才会被执行 那么，接下里解决两个问题： 1、为什么要放在函数里面 2、resolve 是个什么鬼 我们包装好的函数最后，会 return 出 Promise 对象，也就是说，执行这个函数我们得到了一个 Promise 对象。接下来就可以用 Promise 对象上有 then、catch 方法了，这就是 Promise 的强大之处了，看下面的代码： promiseClick().then(function(data){ console.log(data); //后面可以用传过来的数据做些其他操作 //...... }); 这样控制台输出 先是方法被调用起床执行了 promise,最后执行了 promise 的 then 方法，then 方法是一个函数接受一个参数是接受 resolve 返回的数据这事就输出了‘要返回的数据可以任何数据例如接口返回数据’ 这时候你应该有所领悟了，原来 then 里面的函数就跟我们平时的回调函数一个意思，能够在 promiseClick 这个异步任务执行完成之后被执行。这就是 Promise 的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 你可能会觉得在这个和写一个回调函数没有什么区别；那么，如果有多层回调该怎么办？如果 callback 也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个 callback2，然后给 callback 传进去吧。而 Promise 的优势在于，可以在 then 方法中继续写 Promise 对象并返回，然后继续调用 then 来进行回调操作。 所以：精髓在于：Promise 只是能够简化层层回调的写法，而实质上，Promise 的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递 callback 函数要简单、灵活的多。所以使用 Promise 的正确场景是这样的： promiseClick() .then(function(data){ console.log(data); return runAsync2(); }) .then(function(data){ console.log(data); return runAsync3(); }) .then(function(data){ console.log(data); }); 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在 runAsync2 中传给 resolve 的数据，能在接下来的 then 方法中拿到。 （Ps：此处执行多次是因为研究该用法的时候我在一个 react 的 demo 中进行的，该页面多个元素改变导致页面多次渲染执行所致，正常页面只渲染一次的话就所有只会执行一次） reject 的用法 以上是对 promise 的 resolve 用法进行了解释，相当于 resolve 是对 promise 成功时候的回调，它把 promise 的状态修改为 fullfiled，那么，reject 就是失败的时候的回调，他把 promise 的状态修改为 rejected，这样我们在 then 中就能捕捉到，然后执行“失败”情况的回调。 function promiseClick(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('数字太于10了即将执行失败回调'); } }, 2000); }) return p } promiseClick().then( function(data){ console.log(&apos;resolved成功回调&apos;); console.log(&apos;成功回调接受的值：&apos;,data); }, function(reason, data){ console.log(&apos;rejected失败回调&apos;); console.log(&apos;失败执行回调抛出失败原因：&apos;,reason); } ); 执行结果： （PS：此处也是执行多次所以输出多次，执行多次的原因和上次原因一致） 以上代码：调用 promiseClick 方法执行，2 秒后获取到一个随机数，如果小于 10，我们算成功，调用 resolve 修改 Promise 的状态为 fullfiled。否则我们认为是“失败”了，调用 reject 并传递一个参数，作为失败的原因。并将状态改成 rejected 运行 promiseClick 并且在 then 中传了两个参数，这两个参数分别是两个函数，then 方法可以接受两个参数，第一个对应 resolve 的回调，第二个对应 reject 的回调。（也就是说 then 方法中接受两个回调，一个成功的回调函数，一个失败的回调函数，并且能在回调函数中拿到成功的数据和失败的原因），所以我们能够分别拿到成功和失败传过来的数据就有以上的运行结果 catch 的用法 与 Promise 对象方法 then 方法并行的一个方法就是 catch,与 try catch 类似，catch 就是用来捕获异常的，也就是和 then 方法中接受的第二参数 rejected 的回调是一样的，如下： function promiseClick(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('数字太于10了即将执行失败回调'); } }, 2000); }) return p } promiseClick().then( function(data){ console.log(&apos;resolved成功回调&apos;); console.log(&apos;成功回调接受的值：&apos;,data); } ) .catch(function(reason, data){ console.log(&apos;catch到rejected失败回调&apos;); console.log(&apos;catch失败执行回调抛出失败原因：&apos;,reason); }); 执行结果： 效果和写在 then 的第二个参数里面一样。它将大于 10 的情况下的失败回调的原因输出，但是，它还有另外一个作用：在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js，而是会进到这个 catch 方法中。如下： function promiseClick(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('数字太于10了即将执行失败回调'); } }, 2000); }) return p } promiseClick().then( function(data){ console.log(&apos;resolved成功回调&apos;); console.log(&apos;成功回调接受的值：&apos;,data); console.log(noData); } ) .catch(function(reason, data){ console.log(&apos;catch到rejected失败回调&apos;); console.log(&apos;catch失败执行回调抛出失败原因：&apos;,reason); }); 执行结果： 在 resolve 的回调中，我们 console.log(noData);而 noData 这个变量是没有被定义的。如果我们不用 Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到上图的结果，也就是说进到 catch 方法里面去了，而且把错误原因传到了 reason 参数中。即便是有错误的代码也不会报错了 all 的用法 与 then 同级的另一个方法，all 方法，该方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后并且执行结果都是成功的时候才执行回调。 将上述方法复制两份并重命名 promiseClick3(), promiseClick2(), promiseClick1()，如下 function promiseClick1(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('数字太于10了即将执行失败回调'); } }, 2000); }) return p } function promiseClick2(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('数字太于10了即将执行失败回调'); } }, 2000); }) return p } function promiseClick3(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('数字太于10了即将执行失败回调'); } }, 2000); }) return p } Promise .all([promiseClick3(), promiseClick2(), promiseClick1()]) .then(function(results){ console.log(results); }); Promise.all 来执行，all 接收一个数组参数，这组参数为需要执行异步操作的所有方法，里面的值最终都算返回 Promise 对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到 then 里面。那么，三个异步操作返回的数据哪里去了呢？都在 then 里面，all 会把所有异步操作的结果放进一个数组中传给 then，然后再执行 then 方法的成功回调将结果接收，结果如下：（分别执行得到结果，all 统一执行完三个函数并将值存在一个数组里面返回给 then 进行回调输出）： 这样以后就可以用 all 并行执行多个异步操作，并且在一个回调中处理所有的返回数据，比如你需要提前准备好所有数据才渲染页面的时候就可以使用 all,执行多个异步操作将所有的数据处理好，再去渲染 race 的用法 all 是等所有的异步操作都执行完了再执行 then 方法，那么 race 方法就是相反的，谁先执行完成就先执行回调。 我们将上面的方法延迟分别改成 234 秒 function promiseClick1(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('2s随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('2s数字太于10了即将执行失败回调'); } }, 2000); }) return p } function promiseClick2(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('3s随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('3s数字太于10了即将执行失败回调'); } }, 3000); }) return p } function promiseClick3(){ let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('4s随机数生成的值：',num) if(num&lt;=10){ resolve(num); } else{ reject('4s数字太于10了即将执行失败回调'); } }, 4000); }) return p } Promise .race([promiseClick3(), promiseClick2(), promiseClick1()]) .then(function(results){ console.log(results); },function(reason){ console.log(reason); }); 当 2s 后 promiseClick1 执行完成后就已经进入到了 then 里面回调，在 then 里面的回调开始执行时，promiseClick2()和 promiseClick3()并没有停止，仍旧再执行。于是再过 3 秒后，输出了他们各自的回调值 race 的使用比如可以使用在一个请求在 10s 内请求成功的话就走 then 方法，如果 10s 内没有请求成功的话进入 reject 回调执行另一个操作。 转载至 本文为CSDN博主「傻小胖」的原创文章","permalink":"http://blog.loveapple.top/2019/12/13/Promise/","photos":[]},{"tags":[],"title":"uTools","date":"2019/12/13","text":"你的生产力工具集 uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。下载地址","permalink":"http://blog.loveapple.top/2019/12/13/uTools/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/12/12","text":"","permalink":"http://blog.loveapple.top/2019/12/12/hello-world/","photos":[]}]}